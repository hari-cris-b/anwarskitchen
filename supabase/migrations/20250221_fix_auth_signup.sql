-- Begin transaction
BEGIN;

-- Grant access to extensions (needed for crypto functions)
GRANT USAGE ON SCHEMA extensions TO anon;

-- Create extension if not exists
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Grant necessary permissions to anon role for auth signup
GRANT USAGE ON SCHEMA auth TO anon;
GRANT SELECT, INSERT ON auth.users TO anon;
GRANT SELECT, INSERT ON auth.identities TO anon;
GRANT SELECT, INSERT ON auth.sessions TO anon;
GRANT SELECT ON auth.refresh_tokens TO anon;
GRANT SELECT ON auth.instances TO anon;

-- Grant sequence permissions
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA auth TO anon;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO anon;

-- Ensure service role has full access
GRANT ALL ON ALL TABLES IN SCHEMA auth TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO service_role;
GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO service_role;

-- Ensure authenticated role has necessary access
GRANT USAGE ON SCHEMA auth TO authenticated;
GRANT SELECT ON auth.users TO authenticated;
GRANT SELECT ON auth.sessions TO authenticated;

-- Create necessary schemas if they don't exist
CREATE SCHEMA IF NOT EXISTS auth;
CREATE SCHEMA IF NOT EXISTS extensions;

-- Reset permissions to ensure clean state
REVOKE ALL ON ALL TABLES IN SCHEMA auth FROM anon, authenticated;
REVOKE ALL ON ALL SEQUENCES IN SCHEMA auth FROM anon, authenticated;
REVOKE ALL ON ALL ROUTINES IN SCHEMA auth FROM anon, authenticated;

-- Create core auth tables if they don't exist
CREATE TABLE IF NOT EXISTS auth.instances (
    id uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
    uuid uuid,
    raw_base_config text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone
);

CREATE TABLE IF NOT EXISTS auth.users (
    id uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
    instance_id uuid,
    email text,
    encrypted_password text,
    email_confirmed_at timestamp with time zone,
    invited_at timestamp with time zone,
    confirmation_token text,
    confirmation_sent_at timestamp with time zone,
    recovery_token text,
    recovery_sent_at timestamp with time zone,
    email_change_token text,
    email_change text,
    email_change_sent_at timestamp with time zone,
    last_sign_in_at timestamp with time zone,
    raw_app_meta_data jsonb,
    raw_user_meta_data jsonb,
    is_super_admin boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    phone text,
    phone_confirmed_at timestamp with time zone,
    phone_change text,
    phone_change_token text,
    phone_change_sent_at timestamp with time zone,
    confirmed_at timestamp with time zone,
    deleted_at timestamp with time zone,
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT users_phone_key UNIQUE (phone)
);

CREATE TABLE IF NOT EXISTS auth.sessions (
    id uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    factor_id uuid,
    aal aal_level,
    not_after timestamp with time zone
);

CREATE TABLE IF NOT EXISTS auth.refresh_tokens (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    instance_id uuid,
    token text NOT NULL,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    revoked boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    parent text,
    session_id uuid REFERENCES auth.sessions(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS auth.identities (
    id text NOT NULL,
    user_id uuid NOT NULL,
    identity_data jsonb NOT NULL,
    provider text NOT NULL,
    last_sign_in_at timestamp with time zone,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT identities_pkey PRIMARY KEY (provider, id),
    CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Create type if not exists
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'aal_level') THEN
        CREATE TYPE aal_level AS ENUM ('aal1', 'aal2', 'aal3');
    END IF;
END $$;

-- Remove any conflicting RLS on specific auth tables
ALTER TABLE auth.users FORCE ROW LEVEL SECURITY;
ALTER TABLE auth.users DISABLE ROW LEVEL SECURITY;  -- The auth service needs to bypass RLS

-- Ensure proper handling of user metadata
CREATE TABLE IF NOT EXISTS auth.users_meta (
    id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    raw_app_meta_data jsonb,
    raw_user_meta_data jsonb,
    created_at timestamp with time zone,
    updated_at timestamp with time zone
);

GRANT SELECT, INSERT, UPDATE ON auth.users_meta TO anon;

-- Enable row security on auth schema tables
ALTER TABLE auth.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE auth.identities ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Allow identity creation" ON auth.identities;
DROP POLICY IF EXISTS "Allow public registration" ON auth.users;

-- Allow identity creation
CREATE POLICY "Allow identity creation"
    ON auth.identities
    FOR INSERT
    WITH CHECK (true);

-- Drop and recreate policy for user registration with proper checks
DROP POLICY IF EXISTS "Allow public registration" ON auth.users;

CREATE POLICY "Allow public registration"
    ON auth.users
    FOR INSERT
    WITH CHECK (
        -- Email must exist in staff table and be verified
        EXISTS (
            SELECT 1 
            FROM public.staff 
            WHERE email = NEW.email 
            AND email_verified = true
            AND auth_id IS NULL
        )
    );

-- Ensure auth schema exists and is accessible
CREATE SCHEMA IF NOT EXISTS auth;
ALTER SCHEMA auth OWNER TO service_role;
GRANT USAGE ON SCHEMA auth TO postgres, service_role, anon, authenticated;

-- Ensure proper table ownership and permissions
ALTER TABLE auth.users OWNER TO service_role;
GRANT ALL ON TABLE auth.users TO service_role;
GRANT SELECT, INSERT ON TABLE auth.users TO anon;
GRANT SELECT ON TABLE auth.users TO authenticated;

-- Create auth.config table if it doesn't exist
CREATE TABLE IF NOT EXISTS auth.config (
    id integer PRIMARY KEY,
    email_confirm_required boolean DEFAULT false,
    jwt_exp integer DEFAULT 3600,
    jwt_secret text,
    site_url text
);

-- Insert default config if it doesn't exist
INSERT INTO auth.config (id, email_confirm_required, jwt_exp, jwt_secret, site_url)
VALUES (1, false, 3600, current_setting('app.settings.jwt_secret', true), current_setting('app.settings.site_url', true))
ON CONFLICT (id) DO
UPDATE SET 
    email_confirm_required = false,
    jwt_exp = 3600,
    jwt_secret = current_setting('app.settings.jwt_secret', true),
    site_url = current_setting('app.settings.site_url', true);

-- Add comment for documentation
COMMENT ON POLICY "Allow public registration" ON auth.users IS 'Allow registration only for pre-verified staff emails';

-- Create index to improve policy performance
CREATE INDEX IF NOT EXISTS idx_staff_email_auth_status ON public.staff(email, email_verified, auth_id);

-- Re-grant necessary permissions after table creation
GRANT USAGE ON SCHEMA auth TO anon, authenticated;

-- Anonymous permissions
GRANT SELECT, INSERT ON auth.users TO anon;
GRANT SELECT, INSERT ON auth.identities TO anon;
GRANT SELECT, INSERT ON auth.sessions TO anon;
GRANT SELECT ON auth.refresh_tokens TO anon;
GRANT SELECT ON auth.instances TO anon;
GRANT SELECT, INSERT ON auth.users_meta TO anon;

-- Authenticated permissions
GRANT SELECT ON auth.users TO authenticated;
GRANT SELECT ON auth.sessions TO authenticated;
GRANT SELECT ON auth.refresh_tokens TO authenticated;
GRANT SELECT ON auth.identities TO authenticated;
GRANT SELECT ON auth.instances TO authenticated;
GRANT SELECT ON auth.users_meta TO authenticated;

-- Grant sequence permissions
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA auth TO anon, authenticated;

-- Ensure service role maintains full access
GRANT ALL ON ALL TABLES IN SCHEMA auth TO service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO service_role;
GRANT ALL ON ALL ROUTINES IN SCHEMA auth TO service_role;

COMMIT;
